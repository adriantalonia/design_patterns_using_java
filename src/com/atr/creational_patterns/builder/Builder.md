## Builder Design Pattern

Builder pattern aims to “Separate the construction of a complex object from its representation so that the same
construction process can create different representations.” It is used to construct a complex object step by step and
the final step will return the object. The process of constructing an object should be generic so that it can be used to
create different representations of the same object.

![image](https://media.geeksforgeeks.org/wp-content/uploads/uml-of-builedr.jpg)

- **Product** – The product class defines the type of the complex object that is to be generated by the builder pattern.
- **Builder** – This abstract base class defines all of the steps that must be taken in order to correctly create a
  product. Each step is generally abstract as the actual functionality of the builder is carried out in the concrete
  subclasses. The GetProduct method is used to return the final product. The builder class is often replaced with a
  simple interface.
- **ConcreteBuilder** – There may be any number of concrete builder classes inheriting from Builder. These classes
  contain the functionality to create a particular complex product.
- **Director** – The director-class controls the algorithm that generates the final product object. A director object is
  instantiated and its Construct method is called. The method includes a parameter to capture the specific concrete
  builder object that is to be used to generate the product. The director then calls methods of the concrete builder in
  the correct order to generate the product object. On completion of the process, the GetProduct method of the builder
  object can be used to return the product.

### There are 3 major issues

1) too many arguments to pass from the client to the factory class
2) some parameters might be optional
3) if the object is heavy and its creation is complex

### Advantages

- it encapsulates the way a complex object is constructed
    - separates the code of assembling from its representation
    - hides the complex construction process and represents it as a simple process
- allows object to be contracted in a multistep and varying process (as opposed to one-step factories)
- hides the internal representation of the product from the client
- product implementations can be swapped in and out because the client only sees an abstract interface
- focuses on "home the product will be made"

```java

interface HousePlan {
    public void setBasement(String basement);

    public void setStructure(String structure);

    public void setRoof(String roof);

    public void setInterior(String interior);
}
```

```java
class House implements HousePlan {

    private String basement;
    private String structure;
    private String roof;
    private String interior;

    public void setBasement(String basement) {
        this.basement = basement;
    }

    public void setStructure(String structure) {
        this.structure = structure;
    }

    public void setRoof(String roof) {
        this.roof = roof;
    }

    public void setInterior(String interior) {
        this.interior = interior;
    }

}
```

```java
interface HouseBuilder {
    public void buildBasement();

    public void buildStructure();

    public void buildRoof();

    public void buildInterior();

    public House getHouse();
}
```

```java
class IglooHouseBuilder implements HouseBuilder {
    private House house;

    public IglooHouseBuilder() {
        this.house = new House();
    }

    public void buildBasement() {
        house.setBasement("Ice Bars");
    }

    public void buildStructure() {
        house.setStructure("Ice Blocks");
    }

    public void buildInterior() {
        house.setInterior("Ice Carvings");
    }

    public void buildRoof() {
        house.setRoof("Ice Dome");
    }

    public House getHouse() {
        return this.house;
    }
}
```

```java
class TipiHouseBuilder implements HouseBuilder {
    private House house;

    public TipiHouseBuilder() {
        this.house = new House();
    }

    public void buildBasement() {
        house.setBasement("Wooden Poles");
    }

    public void buildStructure() {
        house.setStructure("Wood and Ice");
    }

    public void buildInterior() {
        house.setInterior("Fire Wood");
    }

    public void buildRoof() {
        house.setRoof("Wood, caribou and seal skins");
    }

    public House getHouse() {
        return this.house;
    }

}
```

```java
class CivilEngineer {

    private HouseBuilder houseBuilder;

    public CivilEngineer(HouseBuilder houseBuilder) {
        this.houseBuilder = houseBuilder;
    }

    public House getHouse() {
        return this.houseBuilder.getHouse();
    }

    public void constructHouse() {
        this.houseBuilder.buildBasement();
        this.houseBuilder.buildStructure();
        this.houseBuilder.buildRoof();
        this.houseBuilder.buildInterior();
    }
}
```

```java
class Builder {
    public static void main(String[] args) {
        HouseBuilder iglooBuilder = new IglooHouseBuilder();
        CivilEngineer engineer = new CivilEngineer(iglooBuilder);

        engineer.constructHouse();

        House house = engineer.getHouse();

        System.out.println("Builder constructed: " + house);
    }
}
```

Output :
> Builder constructed: House@6d06d69c